<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/GameBootProfile.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/GameBootProfile.cs" />
              <option name="originalContent" value="using System.Collections.Generic;&#10;using UnityEngine;&#10;&#10;[CreateAssetMenu(fileName = &quot;GameBootProfile&quot;, menuName = &quot;Game/Boot Profile&quot;)]&#10;public class GameBootProfile : ScriptableObject&#10;{&#10;    [Header(&quot;Arranque&quot;)]&#10;    public string sceneToLoad = &quot;MainWorld&quot;;&#10;    public string defaultAnchorId = &quot;Bedroom&quot;;&#10;    public PlayerPresetSO defaultPlayerPreset;&#10;&#10;    [Header(&quot;Boot Settings&quot;)]&#10;    [Tooltip(&quot;Ignora el save y aplica este preset al arrancar&quot;)]&#10;    public bool usePresetInsteadOfSave = false;&#10;    public PlayerPresetSO bootPreset;&#10;    public string startAnchorId = &quot;Bedroom&quot;;&#10;&#10;    [Header(&quot;Runtime Fallback (auto-generado al cargar save)&quot;)]&#10;    public PlayerPresetSO runtimePreset;&#10;&#10;    public bool ShouldBootFromPreset() =&gt; usePresetInsteadOfSave &amp;&amp; bootPreset != null;&#10;&#10;    public string GetStartAnchorOrDefault()&#10;        =&gt; string.IsNullOrEmpty(startAnchorId)&#10;            ? (string.IsNullOrEmpty(defaultAnchorId) ? &quot;Bedroom&quot; : defaultAnchorId)&#10;            : startAnchorId;&#10;&#10;    // ==== NUEVO: API para runtimePreset =======================================&#10;    public void EnsureRuntimePreset()&#10;    {&#10;        if (!runtimePreset)&#10;        {&#10;            runtimePreset = ScriptableObject.CreateInstance&lt;PlayerPresetSO&gt;();&#10;            runtimePreset.name = &quot;RuntimePlayerPreset&quot;;&#10;        }&#10;    }&#10;&#10;    public void SetRuntimePresetFromSave(PlayerSaveData data, PlayerPresetSO slotTemplate = null)&#10;    {&#10;        if (data == null) return;&#10;&#10;        EnsureRuntimePreset();&#10;        var p = runtimePreset;&#10;&#10;        p.level      = data.level;&#10;        p.maxHP      = data.maxHp;     p.currentHP = Mathf.Clamp(data.currentHp, 0f, data.maxHp);&#10;        p.maxMP      = data.maxMp;     p.currentMP = Mathf.Clamp(data.currentMp, 0f, data.maxMp);&#10;        p.unlockedAbilities = new List&lt;AbilityId&gt;(data.abilities ?? new List&lt;AbilityId&gt;());&#10;        p.unlockedSpells    = new List&lt;SpellId&gt;(data.spells    ?? new List&lt;SpellId&gt;());&#10;        p.flags             = new List&lt;string&gt;(data.flags      ?? new List&lt;string&gt;());&#10;&#10;        // Slots: si hay plantilla, respétala; si no, usa los primeros del save&#10;        if (slotTemplate)&#10;        {&#10;            p.leftSpellId    = slotTemplate.leftSpellId;&#10;            p.rightSpellId   = slotTemplate.rightSpellId;&#10;            p.specialSpellId = slotTemplate.specialSpellId;&#10;        }&#10;        else&#10;        {&#10;            p.leftSpellId    = p.unlockedSpells.Count &gt; 0 ? p.unlockedSpells[0] : SpellId.None;&#10;            p.rightSpellId   = p.unlockedSpells.Count &gt; 1 ? p.unlockedSpells[1] : SpellId.None;&#10;            p.specialSpellId = p.unlockedSpells.Count &gt; 2 ? p.unlockedSpells[2] : SpellId.None;&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;Preset activo: bootPreset (si se fuerza), si no runtimePreset, si no default.&lt;/summary&gt;&#10;    public PlayerPresetSO GetActivePresetResolved()&#10;    {&#10;        if (ShouldBootFromPreset() &amp;&amp; bootPreset) return bootPreset;&#10;        if (runtimePreset)                        return runtimePreset;&#10;        return defaultPlayerPreset;&#10;    }&#10;&#10;    // === Helpers =======================================&#10;&#10;    public void ApplyBootPreset(PlayerState ps)&#10;    {&#10;        if (!ps || !bootPreset) return;&#10;        // Con PlayerState nuevo, aplica el preset de una vez:&#10;        ps.ApplyPreset(bootPreset, GetStartAnchorOrDefault());&#10;    }&#10;&#10;    public PlayerSaveData BuildDefaultSave()&#10;    {&#10;        var d = new PlayerSaveData();&#10;        d.lastSpawnAnchorId = string.IsNullOrEmpty(defaultAnchorId) ? &quot;Bedroom&quot; : defaultAnchorId;&#10;        return d;&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="using System.Collections.Generic;&#10;using UnityEngine;&#10;&#10;[CreateAssetMenu(fileName = &quot;GameBootProfile&quot;, menuName = &quot;Game/Boot Profile&quot;)]&#10;public class GameBootProfile : ScriptableObject&#10;{&#10;    [Header(&quot;Arranque&quot;)]&#10;    public string sceneToLoad = &quot;MainWorld&quot;;&#10;    public string defaultAnchorId = &quot;Bedroom&quot;;&#10;    public PlayerPresetSO defaultPlayerPreset;&#10;&#10;    [Header(&quot;Boot Settings&quot;)]&#10;    [Tooltip(&quot;Ignora el save y aplica este preset al arrancar&quot;)]&#10;    public bool usePresetInsteadOfSave = false;&#10;    public PlayerPresetSO bootPreset;&#10;    public string startAnchorId = &quot;Bedroom&quot;;&#10;&#10;    [Header(&quot;Runtime Fallback (auto-generado al cargar save)&quot;)]&#10;    public PlayerPresetSO runtimePreset;&#10;&#10;    public bool ShouldBootFromPreset() =&gt; usePresetInsteadOfSave &amp;&amp; bootPreset != null;&#10;&#10;    public string GetStartAnchorOrDefault()&#10;        =&gt; string.IsNullOrEmpty(startAnchorId)&#10;            ? (string.IsNullOrEmpty(defaultAnchorId) ? &quot;Bedroom&quot; : defaultAnchorId)&#10;            : startAnchorId;&#10;&#10;    // ==== NUEVO: API para runtimePreset =======================================&#10;    public void EnsureRuntimePreset()&#10;    {&#10;        if (!runtimePreset)&#10;        {&#10;            runtimePreset = ScriptableObject.CreateInstance&lt;PlayerPresetSO&gt;();&#10;            runtimePreset.name = &quot;RuntimePlayerPreset&quot;;&#10;        }&#10;    }&#10;&#10;    public void SetRuntimePresetFromSave(PlayerSaveData data, PlayerPresetSO slotTemplate = null)&#10;    {&#10;        if (data == null) return;&#10;&#10;        EnsureRuntimePreset();&#10;        var p = runtimePreset;&#10;&#10;        p.level      = data.level;&#10;        p.maxHP      = data.maxHp;     p.currentHP = Mathf.Clamp(data.currentHp, 0f, data.maxHp);&#10;        p.maxMP      = data.maxMp;     p.currentMP = Mathf.Clamp(data.currentMp, 0f, data.maxMp);&#10;        p.unlockedAbilities = new List&lt;AbilityId&gt;(data.abilities ?? new List&lt;AbilityId&gt;());&#10;        p.unlockedSpells    = new List&lt;SpellId&gt;(data.spells    ?? new List&lt;SpellId&gt;());&#10;        p.flags             = new List&lt;string&gt;(data.flags      ?? new List&lt;string&gt;());&#10;&#10;        // Slots: si hay plantilla, respétala; si no, usa los primeros del save&#10;        if (slotTemplate)&#10;        {&#10;            p.leftSpellId    = slotTemplate.leftSpellId;&#10;            p.rightSpellId   = slotTemplate.rightSpellId;&#10;            p.specialSpellId = slotTemplate.specialSpellId;&#10;        }&#10;        else&#10;        {&#10;            p.leftSpellId    = p.unlockedSpells.Count &gt; 0 ? p.unlockedSpells[0] : SpellId.None;&#10;            p.rightSpellId   = p.unlockedSpells.Count &gt; 1 ? p.unlockedSpells[1] : SpellId.None;&#10;            p.specialSpellId = p.unlockedSpells.Count &gt; 2 ? p.unlockedSpells[2] : SpellId.None;&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;Preset activo: bootPreset (si se fuerza), si no runtimePreset, si no default.&lt;/summary&gt;&#10;    public PlayerPresetSO GetActivePresetResolved()&#10;    {&#10;        if (ShouldBootFromPreset() &amp;&amp; bootPreset) return bootPreset;&#10;        if (runtimePreset)                        return runtimePreset;&#10;        return defaultPlayerPreset;&#10;    }&#10;&#10;    // === Helpers =======================================&#10;&#10;    public void ApplyBootPreset(PlayerState ps)&#10;    {&#10;        if (!ps || !bootPreset) return;&#10;        // Con PlayerState nuevo, aplica el preset de una vez:&#10;        ps.ApplyPreset(bootPreset, GetStartAnchorOrDefault());&#10;    }&#10;&#10;    public PlayerSaveData BuildDefaultSave()&#10;    {&#10;        var d = new PlayerSaveData();&#10;        d.lastSpawnAnchorId = string.IsNullOrEmpty(defaultAnchorId) ? &quot;Bedroom&quot; : defaultAnchorId;&#10;        return d;&#10;    }&#10;&#10;    // === NUEVO: Métodos para guardar/cargar el profile completo ===&#10;    &#10;    /// &lt;summary&gt;Guarda el estado actual del profile en el SaveSystem&lt;/summary&gt;&#10;    public bool SaveProfile(SaveSystem saveSystem)&#10;    {&#10;        if (!saveSystem) return false;&#10;        &#10;        var data = BuildSaveDataFromProfile();&#10;        return saveSystem.Save(data);&#10;    }&#10;    &#10;    /// &lt;summary&gt;Carga datos del SaveSystem y los aplica al profile&lt;/summary&gt;&#10;    public bool LoadProfile(SaveSystem saveSystem)&#10;    {&#10;        if (!saveSystem || !saveSystem.HasSave()) return false;&#10;        &#10;        if (saveSystem.Load(out var data))&#10;        {&#10;            ApplySaveDataToProfile(data);&#10;            return true;&#10;        }&#10;        return false;&#10;    }&#10;    &#10;    /// &lt;summary&gt;Actualiza el profile con el estado actual del PlayerState y guarda&lt;/summary&gt;&#10;    public bool SaveCurrentGameState(SaveSystem saveSystem, PlayerState playerState)&#10;    {&#10;        if (!saveSystem || !playerState) return false;&#10;        &#10;        // Actualizar el runtimePreset con el estado actual del jugador&#10;        UpdateRuntimePresetFromPlayerState(playerState);&#10;        &#10;        // Guardar el profile actualizado&#10;        return SaveProfile(saveSystem);&#10;    }&#10;    &#10;    /// &lt;summary&gt;Construye PlayerSaveData a partir del estado actual del profile&lt;/summary&gt;&#10;    private PlayerSaveData BuildSaveDataFromProfile()&#10;    {&#10;        var activePreset = GetActivePresetResolved();&#10;        if (!activePreset) return BuildDefaultSave();&#10;        &#10;        var data = new PlayerSaveData();&#10;        data.lastSpawnAnchorId = SpawnManager.CurrentAnchorId ?? defaultAnchorId;&#10;        data.level = activePreset.level;&#10;        data.maxHp = activePreset.maxHP;&#10;        data.currentHp = activePreset.currentHP;&#10;        data.maxMp = activePreset.maxMP;&#10;        data.currentMp = activePreset.currentMP;&#10;        data.abilities = new List&lt;AbilityId&gt;(activePreset.unlockedAbilities ?? new List&lt;AbilityId&gt;());&#10;        data.spells = new List&lt;SpellId&gt;(activePreset.unlockedSpells ?? new List&lt;SpellId&gt;());&#10;        data.flags = new List&lt;string&gt;(activePreset.flags ?? new List&lt;string&gt;());&#10;        &#10;        return data;&#10;    }&#10;    &#10;    /// &lt;summary&gt;Aplica datos de PlayerSaveData al profile (actualiza runtimePreset)&lt;/summary&gt;&#10;    private void ApplySaveDataToProfile(PlayerSaveData data)&#10;    {&#10;        if (data == null) return;&#10;        &#10;        // Actualizar el anchorId por defecto si es necesario&#10;        if (!string.IsNullOrEmpty(data.lastSpawnAnchorId))&#10;        {&#10;            defaultAnchorId = data.lastSpawnAnchorId;&#10;        }&#10;        &#10;        // Crear/actualizar runtimePreset con los datos cargados&#10;        SetRuntimePresetFromSave(data, defaultPlayerPreset);&#10;    }&#10;    &#10;    /// &lt;summary&gt;Actualiza runtimePreset con los datos actuales del PlayerState&lt;/summary&gt;&#10;    private void UpdateRuntimePresetFromPlayerState(PlayerState playerState)&#10;    {&#10;        EnsureRuntimePreset();&#10;        var p = runtimePreset;&#10;        &#10;        // Actualizar posición actual&#10;        defaultAnchorId = SpawnManager.CurrentAnchorId ?? defaultAnchorId;&#10;        &#10;        // Actualizar datos del jugador desde PlayerState&#10;        p.level = playerState.Level;&#10;        p.maxHP = playerState.MaxHp;&#10;        p.currentHP = playerState.CurrentHp;&#10;        p.maxMP = playerState.MaxMp;&#10;        p.currentMP = playerState.CurrentMp;&#10;        p.unlockedAbilities = new List&lt;AbilityId&gt;(playerState.GetAbilitiesSnapshot() ?? new List&lt;AbilityId&gt;());&#10;        p.unlockedSpells = new List&lt;SpellId&gt;(playerState.GetSpellsSnapshot() ?? new List&lt;SpellId&gt;());&#10;        p.flags = new List&lt;string&gt;(playerState.GetFlagsSnapshot() ?? new List&lt;string&gt;());&#10;        &#10;        // Mantener configuración de slots actuales si existen&#10;        // (o podrías obtenerlos también del PlayerState si tienes esa info)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>